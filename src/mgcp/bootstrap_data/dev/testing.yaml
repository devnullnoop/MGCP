lessons:
  - id: testing
    trigger: "When writing tests, debugging code, or validating that implementations produce expected outputs before integration"
    action: "Write tests with explicit expected outputs BEFORE integrating. Run tests after every change. Red test = stop and fix immediately."
    rationale: "Bugs discovered during integration require debugging across boundaries. Bugs discovered in isolation have one-line fixes. Test early or debug late—the choice costs 10x either way."
    tags: [meta, testing, quality]

  - id: test-known-inputs
    trigger: "When writing unit tests or validating function outputs — test with known input/output pairs first to establish a baseline"
    action: "Test functions with known input/output pairs first"
    rationale: "Known pairs make it obvious when behavior changes"
    parent_id: testing
    tags: [testing, unit-tests]
    examples:
      - label: good
        code: |
          def test_parse_date():
              assert parse_date('2024-01-15') == date(2024, 1, 15)
        explanation: "Known input, known output, easy to verify"

  - id: test-edge-cases
    trigger: "When testing edge cases and boundary conditions — always cover empty inputs, null values, zero, and maximum values"
    action: "Always test empty, null, zero, and boundary values"
    rationale: "Edge cases cause most production bugs"
    parent_id: testing
    tags: [testing, edge-cases]
    examples:
      - label: good
        code: |
          def test_process_list():
              assert process([]) == []  # empty
              assert process([1]) == [1]  # single
              assert process(None) raises ValueError
        explanation: "Empty, single, and null cases covered"
