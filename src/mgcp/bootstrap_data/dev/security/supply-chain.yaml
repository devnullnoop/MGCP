# =============================================================================
# PILLAR 7: SUPPLY CHAIN & DEPENDENCY MANAGEMENT
# Sources: OWASP A03/A08, LLM03, SSDF PS.1-3
# =============================================================================

lessons:
  - id: security-supply-chain
    trigger: "When managing third-party dependencies, build pipelines, or software releases — securing the supply chain from dependency selection through release verification"
    action: "Treat the supply chain as an attack surface. Verify dependency integrity, monitor for vulnerabilities, audit transitive dependencies, pin versions, and secure your own build and release process."
    rationale: "Supply chain attacks (SolarWinds, Log4Shell, ua-parser-js, event-stream) compromise thousands of organizations through a single trusted dependency. OWASP A06 (Vulnerable and Outdated Components) and A08 (Software and Data Integrity Failures) address this directly."
    tags: [security, supply-chain, dependencies]
    parent_id: security

  - id: dependency-integrity
    trigger: "When installing or updating dependencies — verifying that downloaded packages are authentic and have not been tampered with"
    action: "Use lockfiles (package-lock.json, poetry.lock, Cargo.lock) to pin exact dependency versions and checksums. Verify package signatures where available. Use a private registry or registry mirror for corporate environments. Enable lockfile-only installs in CI (npm ci, pip install --require-hashes)."
    rationale: "Without integrity verification, attackers can substitute malicious packages via typosquatting, registry compromise, or man-in-the-middle attacks. Lockfiles with checksums ensure you get the exact bytes you reviewed."
    tags: [security, supply-chain, integrity, lockfiles]
    parent_id: security-supply-chain
    examples:
      - label: bad
        code: |
          # requirements.txt without hashes
          requests>=2.28
          flask

          # Install without lockfile enforcement
          pip install -r requirements.txt
        explanation: "No version pins, no hashes - pip fetches whatever is latest, no integrity check"
      - label: good
        code: |
          # requirements.txt with hashes (generated by pip-compile --generate-hashes)
          requests==2.31.0 \
              --hash=sha256:58cd2187c01e70e6e26505bca751777aa9f2ee0b7f4300988b709f44e013003eb
          flask==3.0.0 \
              --hash=sha256:21128f47e4e3b9d597a3e8521a329bf56909b690fcc3fa3e477725aa81367638

          # Install with hash verification
          pip install --require-hashes -r requirements.txt
        explanation: "Exact versions pinned with cryptographic hashes - any tampering causes install failure"

  - id: dependency-monitoring
    trigger: "When maintaining a codebase with third-party dependencies — setting up automated monitoring for newly discovered vulnerabilities (CVEs)"
    action: "Enable automated vulnerability scanning with tools like Dependabot, Snyk, Renovate, or pip-audit. Configure alerts for critical/high severity CVEs. Set up automated PR creation for security patches. Review and merge security updates within days, not weeks."
    rationale: "New CVEs are discovered daily. Manual checking is unsustainable. Log4Shell (CVE-2021-44228) demonstrated that even widely-used libraries can have critical vulnerabilities that require immediate patching."
    tags: [security, supply-chain, monitoring, cve, vulnerability]
    parent_id: security-supply-chain
    examples:
      - label: good
        code: |
          # .github/dependabot.yml
          version: 2
          updates:
            - package-ecosystem: "pip"
              directory: "/"
              schedule:
                interval: "daily"
              open-pull-requests-limit: 10
              labels:
                - "dependencies"
                - "security"
        explanation: "Dependabot checks for vulnerable dependencies daily and opens PRs automatically"

  - id: sbom-maintenance
    trigger: "When managing software composition, regulatory compliance, or preparing for security audits — creating and maintaining a Software Bill of Materials"
    action: "Generate and maintain a Software Bill of Materials (SBOM) in standard format (SPDX or CycloneDX). Include all direct and transitive dependencies with versions and licenses. Update the SBOM on every release. Store SBOMs alongside releases for traceability."
    rationale: "When a critical CVE drops (like Log4Shell), an SBOM lets you answer 'are we affected?' in minutes instead of days. Regulatory frameworks (US Executive Order 14028, EU Cyber Resilience Act) increasingly require SBOMs."
    tags: [security, supply-chain, sbom, compliance]
    parent_id: security-supply-chain
    examples:
      - label: good
        code: |
          # Generate CycloneDX SBOM for a Python project
          pip install cyclonedx-bom
          cyclonedx-py requirements -i requirements.txt -o sbom.json --format json

          # Or using syft for container images
          syft your-image:latest -o cyclonedx-json > sbom.json
        explanation: "Standard-format SBOM generated from actual dependencies, machine-readable for automated CVE matching"

  - id: transitive-dependency-audit
    trigger: "When evaluating the security posture of project dependencies — looking beyond direct dependencies to audit the full dependency tree"
    action: "Audit the full dependency tree, not just direct dependencies. Use tools like pipdeptree, npm ls, or cargo tree to visualize transitive dependencies. Check for known vulnerabilities in transitive dependencies. Be wary of deep dependency trees that pull in hundreds of packages."
    rationale: "Most vulnerabilities are in transitive dependencies you never explicitly chose. The event-stream attack targeted a transitive dependency. A project with 10 direct dependencies often has 100+ transitive dependencies, each a potential attack vector."
    tags: [security, supply-chain, transitive, audit]
    parent_id: security-supply-chain
    examples:
      - label: good
        code: |
          # Python: visualize full dependency tree
          pip install pipdeptree
          pipdeptree --warn fail  # Fail on circular dependencies

          # Audit all dependencies (direct + transitive)
          pip install pip-audit
          pip-audit  # Checks all installed packages against known CVEs

          # Node: list full dependency tree
          npm ls --all
          npm audit  # Check for known vulnerabilities
        explanation: "Visualize and audit the full tree - transitive vulnerabilities are just as exploitable as direct ones"

  - id: version-pinning
    trigger: "When specifying dependency versions for production deployments — choosing between exact pins, ranges, and floating versions"
    action: "Pin exact versions in production (==, not >=). Use lockfiles to freeze the entire dependency tree. Reserve version ranges for libraries you publish (to avoid conflicts). Test upgrades explicitly in CI before adopting new versions."
    rationale: "Floating version ranges mean your production build can change without any code change. A malicious minor version release (like ua-parser-js 0.7.29) gets automatically installed on your next build. Exact pins ensure reproducible, audited builds."
    tags: [security, supply-chain, versioning, pinning]
    parent_id: security-supply-chain
    examples:
      - label: bad
        code: |
          # requirements.txt with floating versions
          requests>=2.20
          flask~=2.0
          pydantic
        explanation: "Any future release is automatically trusted - a compromised version auto-installs"
      - label: good
        code: |
          # requirements.txt with exact pins
          requests==2.31.0
          flask==3.0.0
          pydantic==2.5.2

          # Upgrade explicitly and test
          # pip install requests==2.32.0
          # pytest  # Verify nothing breaks
          # Update requirements.txt
        explanation: "Exact pins ensure reproducible builds; upgrades are deliberate and tested"

  - id: dependency-evaluation
    trigger: "When considering whether to adopt a new third-party library or framework — evaluating its security posture, maintenance status, and trustworthiness"
    action: "Before adopting a dependency, evaluate: (1) maintenance activity (recent commits, responsive to issues), (2) security track record (past CVEs and response time), (3) license compatibility, (4) number of maintainers (bus factor), (5) download count and community adoption, (6) dependency footprint (what does it pull in). Prefer well-maintained, widely-adopted packages."
    rationale: "Every dependency is code you trust to run with your privileges. Abandoned packages don't get security patches. Single-maintainer packages are vulnerable to account takeover (the event-stream attack). Heavy dependency trees expand attack surface."
    tags: [security, supply-chain, evaluation, due-diligence]
    parent_id: security-supply-chain
    examples:
      - label: bad
        code: |
          # Adopting a package without evaluation
          pip install cool-new-lib  # 12 stars, 1 contributor, last commit 2 years ago
        explanation: "No evaluation - could be abandoned, malicious, or poorly maintained"
      - label: good
        code: |
          # Evaluation checklist before adoption
          # 1. Check GitHub: stars, contributors, recent activity
          # 2. Check PyPI/npm: download stats, version history
          # 3. Check Snyk/CVE databases for known vulnerabilities
          # 4. Review license compatibility (MIT/Apache OK, GPL may not be)
          # 5. Run: pipdeptree -p cool-new-lib  # Check what it pulls in
          # 6. Review source code for obvious red flags
        explanation: "Systematic evaluation before trusting third-party code"

  - id: ci-cd-integrity
    trigger: "When configuring CI/CD pipelines, build systems, or deployment automation — protecting the build process from supply chain attacks"
    action: "Secure CI/CD pipelines: (1) require signed commits on protected branches, (2) enforce branch protection and review requirements, (3) use least-privilege access for pipeline service accounts, (4) pin CI action versions by hash (not tag), (5) audit pipeline secrets access, (6) use ephemeral build environments."
    rationale: "CI/CD pipelines have access to production credentials and deployment targets. A compromised pipeline can inject backdoors into every release. SolarWinds demonstrated that build system compromise can affect thousands of downstream customers."
    tags: [security, supply-chain, ci-cd, pipeline, build]
    parent_id: security-supply-chain
    examples:
      - label: bad
        code: |
          # .github/workflows/deploy.yml
          steps:
            - uses: actions/checkout@v4  # Tag can be moved to malicious commit
            - uses: some-org/deploy-action@main  # Main branch - always latest
            - run: echo ${{ secrets.DEPLOY_KEY }}  # Secret in logs
        explanation: "Mutable action references, unpinned versions, secret leakage"
      - label: good
        code: |
          # .github/workflows/deploy.yml
          steps:
            - uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11  # v4.1.1
            - uses: some-org/deploy-action@a1b2c3d4e5f6  # Pinned to exact commit
            - run: ./deploy.sh  # Script handles secrets internally, never echoed
        explanation: "Actions pinned by commit hash (immutable), secrets never exposed in logs"

  - id: release-verification
    trigger: "When publishing software releases or distributing build artifacts — signing releases and providing integrity verification for consumers"
    action: "Sign all release artifacts with GPG or Sigstore. Publish checksums (SHA-256) alongside releases. Use reproducible builds where possible so anyone can verify the binary matches the source. Provide verification instructions for downstream consumers."
    rationale: "Without signed releases, consumers cannot verify authenticity. Attackers who compromise a distribution channel (CDN, package registry, GitHub releases) can substitute malicious binaries. Signing enables detection of tampering."
    tags: [security, supply-chain, releases, signing, integrity]
    parent_id: security-supply-chain
    examples:
      - label: good
        code: |
          # Sign release with GPG
          gpg --armor --detach-sign dist/myapp-1.0.0.tar.gz

          # Generate checksums
          sha256sum dist/myapp-1.0.0.tar.gz > dist/SHA256SUMS
          gpg --armor --detach-sign dist/SHA256SUMS

          # Or use sigstore for keyless signing
          cosign sign-blob dist/myapp-1.0.0.tar.gz \
              --bundle myapp-1.0.0.tar.gz.bundle
        explanation: "GPG or Sigstore signatures let consumers verify release authenticity and integrity"
